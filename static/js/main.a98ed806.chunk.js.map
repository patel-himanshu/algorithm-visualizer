{"version":3,"sources":["components/Navbar/Navbar.js","algorithms/Dijkstra.js","components/Legend/Legend.js","components/Node/Node.js","components/Visualizer/Visualizer.js","App.js","reportWebVitals.js","index.js"],"names":["Navbar","className","Component","dijkstra","board","sourceNode","targetNode","result","visitedNodes","pathExists","distance","priorityQueue","allNodes","row","node","push","getAllNodes","length","sort","node1","node2","nearestNeighbourNode","shift","isWall","Infinity","isVisited","updateNeighbourNodes","unvisitedNeighbours","neighbours","col","rowLength","colLength","filter","neighbour","getUnvisitedNeighbours","parentNode","Legend","name","nodeClass","map","legendItem","idx","style","cursor","Node","this","props","isSourceNode","isTargetNode","onClick","otherClassName","id","SOURCE_NODE_ROW","Math","floor","random","SOURCE_NODE_COL","TARGET_NODE_ROW","TARGET_NODE_COL","Visualizer","state","isVisualizationStarted","pathLength","numNodesVisited","boardRow","boardCol","sourceRow","sourceCol","targetRow","targetCol","getBoardArray","setState","shortestPathOrder","i","setTimeout","animateShortestPath","document","getElementById","unshift","pop","getShortestPath","animateDijkstra","window","location","reload","newNode","finalMessage","border","visualize","onMouseDown","e","preventDefault","disabled","handleBoardReset","boardRowIdx","boardColIdx","handleClick","textShadow","currRow","createNode","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.a98ed806.chunk.js","sourcesContent":["import React, { Component } from \"react\";\r\nimport \"bootstrap/dist/css/bootstrap.min.css\";\r\n\r\nexport default class Navbar extends Component {\r\n  render() {\r\n    return (\r\n      <div>\r\n        <nav className=\"navbar bg-primary text-light sticky-top\">\r\n          <div className=\"navbar-brand font-weight-bold\">\r\n            Algorithm Visualizer\r\n          </div>\r\n        </nav>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n","export function dijkstra(board, sourceNode, targetNode) {\r\n  const result = { visitedNodes: [], pathExists: false };\r\n  sourceNode.distance = 0;\r\n\r\n  // Creates a 1D array of unvisited nodes, which is sorted\r\n  const priorityQueue = getAllNodes(board);\r\n\r\n  while (priorityQueue.length !== 0) {\r\n    // Sorts the priority queue in ascending order w.r.t. distance\r\n    priorityQueue.sort((node1, node2) => node1.distance - node2.distance);\r\n\r\n    // Selects the unvisited node with least distance as nearest node,\r\n    // sets it as the latest visited node and removes it from the unvisited nodes array\r\n    const nearestNeighbourNode = priorityQueue.shift();\r\n\r\n    if (nearestNeighbourNode.isWall) continue;\r\n    if (nearestNeighbourNode.distance === Infinity) {\r\n      result.pathExists = false;\r\n      return result;\r\n    }\r\n\r\n    result.visitedNodes.push(nearestNeighbourNode);\r\n    nearestNeighbourNode.isVisited = true;\r\n\r\n    if (nearestNeighbourNode === targetNode) {\r\n      result.pathExists = true;\r\n      return result;\r\n    }\r\n\r\n    updateNeighbourNodes(board, nearestNeighbourNode);\r\n  }\r\n}\r\n\r\n// Creates a 1D array of all nodes of the board\r\nfunction getAllNodes(board) {\r\n  const allNodes = [];\r\n  for (let row of board) {\r\n    for (let node of row) {\r\n      allNodes.push(node);\r\n    }\r\n  }\r\n  return allNodes;\r\n}\r\n\r\n// Get a 1D array of unvisited neighbour nodes of current node\r\nfunction getUnvisitedNeighbours(board, node) {\r\n  const neighbours = [];\r\n  const { row, col } = node;\r\n  const rowLength = board.length;\r\n  const colLength = board[0].length;\r\n\r\n  if (row > 0) neighbours.push(board[row - 1][col]);\r\n  if (col > 0) neighbours.push(board[row][col - 1]);\r\n  if (row < rowLength - 1) neighbours.push(board[row + 1][col]);\r\n  if (col < colLength - 1) neighbours.push(board[row][col + 1]);\r\n\r\n  return neighbours.filter((neighbour) => !neighbour.isVisited);\r\n}\r\n\r\n// Increments the distance of all unvisited neighbour nodes by 1\r\n// Sets the parent node for all unvisited neighbour nodes\r\nfunction updateNeighbourNodes(board, node) {\r\n  const unvisitedNeighbours = getUnvisitedNeighbours(board, node);\r\n\r\n  for (let neighbour of unvisitedNeighbours) {\r\n    neighbour.distance = node.distance + 1;\r\n    neighbour.parentNode = node;\r\n  }\r\n}\r\n\r\n// Returns the shortest path obtained using Dijkstra'a algorithm\r\n// Excludes the source node and the target node\r\nexport function getShortestPath(targetNode) {\r\n  const shortestPathOrder = [];\r\n  let node = targetNode;\r\n  while (node != null) {\r\n    shortestPathOrder.unshift(node);\r\n    node = node.parentNode;\r\n  }\r\n  shortestPathOrder.shift();\r\n  shortestPathOrder.pop();\r\n  return shortestPathOrder;\r\n}\r\n","import React, { Component } from \"react\";\r\n\r\nexport default class Legend extends Component {\r\n  render() {\r\n    const legend = [\r\n      { name: \"Source Node\", nodeClass: \"node-source\" },\r\n      { name: \"Target Node\", nodeClass: \"node-target\" },\r\n      { name: \"Wall Node\", nodeClass: \"node-wall\" },\r\n      { name: \"Unvisited Node\", nodeClass: \"node\" },\r\n      { name: \"Visited Node\", nodeClass: \"node-visited\" },\r\n      {\r\n        name: \"Shortest Path\",\r\n        nodeClass: \"node-shortest-path node-legend-final\",\r\n      },\r\n    ];\r\n\r\n    return (\r\n      <div className=\"container legend my-2 fixed-bottom\">\r\n        {/* <div className=\"mb-1 font-weight-bold\" style={{ cursor: \"default\" }}>\r\n          Legend:\r\n        </div> */}\r\n        {legend.map((legendItem, idx) => {\r\n          const { name, nodeClass } = legendItem;\r\n          return (\r\n            <button key={idx} className=\"mr-2\" style={{ cursor: \"default\" }}>\r\n              <div className={`node node-legend ${nodeClass}`}></div> {name}\r\n            </button>\r\n          );\r\n        })}\r\n        <div\r\n          className=\"mt-1 font-weight-bold text-danger\"\r\n          style={{ cursor: \"default\" }}\r\n        >\r\n          Note: View on the maximized window of a computer screen for better\r\n          experience.\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n","import React, { Component } from \"react\";\r\nimport \"./Node.css\";\r\n\r\nexport default class Node extends Component {\r\n  render() {\r\n    const {\r\n      row,\r\n      col,\r\n      isWall,\r\n      isSourceNode,\r\n      isTargetNode,\r\n      onClick,\r\n    } = this.props;\r\n\r\n    let otherClassName = \"\";\r\n    if (isSourceNode) {\r\n      otherClassName = \"node-source\";\r\n    } else if (isTargetNode) {\r\n      otherClassName = \"node-target\";\r\n    } else if (isWall) {\r\n      otherClassName = \"node-wall\";\r\n    }\r\n\r\n    return (\r\n      <div\r\n        id={`node-${row}-${col}`}\r\n        className={`node ${otherClassName}`}\r\n        onClick={() => onClick(row, col)}\r\n      ></div>\r\n    );\r\n  }\r\n}\r\n","import React, { Component } from \"react\";\r\nimport { dijkstra, getShortestPath } from \"../../algorithms/Dijkstra\";\r\nimport Legend from \"../Legend/Legend\";\r\nimport Node from \"../Node/Node\";\r\nimport \"./Visualizer.css\";\r\n\r\nconst BOARD_WIDTH = 30;\r\nconst BOARD_HEIGHT = 10;\r\nconst SOURCE_NODE_ROW = Math.floor(Math.random() * BOARD_HEIGHT);\r\nconst SOURCE_NODE_COL = Math.floor(Math.random() * BOARD_WIDTH);\r\nconst TARGET_NODE_ROW = Math.floor(Math.random() * BOARD_HEIGHT);\r\nconst TARGET_NODE_COL = Math.floor(Math.random() * BOARD_WIDTH);\r\n\r\n// const BOARD_WIDTH = 3;\r\n// const BOARD_HEIGHT = 3;\r\n// const SOURCE_NODE_ROW = 1;\r\n// const SOURCE_NODE_COL = 0;\r\n// const TARGET_NODE_ROW = 2;\r\n// const TARGET_NODE_COL = 2;\r\n\r\nexport default class Visualizer extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      board: [],\r\n      isVisualizationStarted: false,\r\n      pathLength: null,\r\n      numNodesVisited: 0,\r\n      boardRow: BOARD_WIDTH,\r\n      boardCol: BOARD_HEIGHT,\r\n      sourceRow: SOURCE_NODE_ROW,\r\n      sourceCol: SOURCE_NODE_COL,\r\n      targetRow: TARGET_NODE_ROW,\r\n      targetCol: TARGET_NODE_COL,\r\n    };\r\n  }\r\n\r\n  // Creates a 2D board array after the mounting phase of the component gets completed\r\n  componentDidMount() {\r\n    const board = getBoardArray();\r\n    this.setState({ board: board });\r\n  }\r\n\r\n  animateDijkstra(visitedNodes, pathExists, shortestPathOrder) {\r\n    for (let i = 0; i <= visitedNodes.length; i++) {\r\n      if (i === visitedNodes.length) {\r\n        setTimeout(() => {\r\n          this.animateShortestPath(shortestPathOrder, pathExists);\r\n        }, 20 * i);\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodes[i];\r\n        if (\r\n          !(node.row === SOURCE_NODE_ROW && node.col === SOURCE_NODE_COL) &&\r\n          !(node.row === TARGET_NODE_ROW && node.col === TARGET_NODE_COL)\r\n        ) {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-visited\";\r\n        }\r\n      }, 20 * i);\r\n    }\r\n  }\r\n\r\n  animateShortestPath(shortestPathOrder, pathExists) {\r\n    document.getElementById(\r\n      `node-${SOURCE_NODE_ROW}-${SOURCE_NODE_COL}`\r\n    ).className = \"node node-source node-final\";\r\n\r\n    for (let i = 0; i < shortestPathOrder.length; i++) {\r\n      setTimeout(() => {\r\n        const node = shortestPathOrder[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node-shortest-path node-final\";\r\n      }, 100 * i);\r\n    }\r\n\r\n    document.getElementById(\r\n      `node-${TARGET_NODE_ROW}-${TARGET_NODE_COL}`\r\n    ).className = \"node node-target node-final\";\r\n\r\n    if (pathExists) {\r\n      this.setState({ pathLength: shortestPathOrder.length });\r\n    } else {\r\n      this.setState({ pathLength: Infinity });\r\n    }\r\n  }\r\n\r\n  visualize() {\r\n    this.setState({ isVisualizationStarted: true });\r\n    const { board } = this.state;\r\n    const sourceNode = board[SOURCE_NODE_ROW][SOURCE_NODE_COL];\r\n    const targetNode = board[TARGET_NODE_ROW][TARGET_NODE_COL];\r\n    const { visitedNodes, pathExists } = dijkstra(\r\n      board,\r\n      sourceNode,\r\n      targetNode\r\n    );\r\n    const shortestPathOrder = getShortestPath(targetNode);\r\n    this.animateDijkstra(visitedNodes, pathExists, shortestPathOrder);\r\n    this.setState({ numNodesVisited: visitedNodes.length });\r\n  }\r\n\r\n  handleBoardReset() {\r\n    window.location.reload(false);\r\n    this.state({ isVisualizationStarted: false });\r\n    // const board = getBoardArray();\r\n    // this.setState({ board: board, pathLength: 0 });\r\n  }\r\n\r\n  handleClick(row, col) {\r\n    // console.log(\"Clicked\", row, col);\r\n    if (!this.state.isVisualizationStarted) {\r\n      const { board } = this.state;\r\n      const node = board[row][col];\r\n      const newNode = {\r\n        ...node,\r\n        isWall: !node.isWall,\r\n      };\r\n      board[row][col] = newNode;\r\n      // console.log(node);\r\n      // console.log(newNode);\r\n      this.setState({ board });\r\n    }\r\n  }\r\n\r\n  render() {\r\n    const {\r\n      board,\r\n      pathLength,\r\n      numNodesVisited,\r\n      boardRow,\r\n      boardCol,\r\n    } = this.state;\r\n    let finalMessage =\r\n      pathLength === Infinity\r\n        ? \"There is no path connecting the source and target node\"\r\n        : pathLength === 0\r\n        ? \"The source and target nodes are adjacent to each other\"\r\n        : `The number of nodes in shortest path between source and target\r\n    node: ${pathLength}`;\r\n\r\n    return (\r\n      <>\r\n        {/* Action Buttons */}\r\n        <button\r\n          className=\"btn btn-warning mt-4 mr-2\"\r\n          style={{ border: \"2px solid black\" }}\r\n          onClick={() => this.visualize()}\r\n          onMouseDown={(e) => e.preventDefault()}\r\n          disabled={this.state.isVisualizationStarted}\r\n        >\r\n          Visualize Dijkstra's Algorithm\r\n        </button>\r\n        <button\r\n          className=\"btn btn-danger mt-4 ml-2\"\r\n          style={{ border: \"2px solid black\" }}\r\n          onClick={() => this.handleBoardReset()}\r\n          onMouseDown={(e) => e.preventDefault()}\r\n        >\r\n          Reset Board\r\n        </button>\r\n\r\n        {/* Board and Node Details */}\r\n        <div className=\"container mt-2\">\r\n          <h4>\r\n            Board has {boardRow} rows and {boardCol} columns\r\n          </h4>\r\n        </div>\r\n\r\n        {/* Board Layout */}\r\n        <div className=\"mb-2\">\r\n          <div className=\"board-layout\">\r\n            {board.map((boardRow, boardRowIdx) => {\r\n              return (\r\n                <div key={boardRowIdx} className=\"board-row\">\r\n                  {boardRow.map((boardCol, boardColIdx) => {\r\n                    const {\r\n                      row,\r\n                      col,\r\n                      isWall,\r\n                      isSourceNode,\r\n                      isTargetNode,\r\n                    } = boardCol;\r\n                    return (\r\n                      <Node\r\n                        key={boardColIdx}\r\n                        row={row}\r\n                        col={col}\r\n                        isWall={isWall}\r\n                        isSourceNode={isSourceNode}\r\n                        isTargetNode={isTargetNode}\r\n                        onClick={(row, col) => this.handleClick(row, col)}\r\n                      />\r\n                    );\r\n                  })}\r\n                </div>\r\n              );\r\n            })}\r\n          </div>\r\n          {pathLength !== null && (\r\n            <div className=\"div\">\r\n              <h4 style={{ textShadow: \"0 0 10px orange\" }}>{finalMessage}</h4>\r\n              <h5>The total number of nodes visited: {numNodesVisited}</h5>\r\n            </div>\r\n          )}\r\n        </div>\r\n\r\n        {/* Legend */}\r\n        <Legend />\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\n// Creates a 2D array of board, of given dimensions\r\n// Each node of the board, has its own set of properties\r\nconst getBoardArray = () => {\r\n  const board = [];\r\n  for (let row = 0; row < BOARD_HEIGHT; row++) {\r\n    let currRow = [];\r\n    for (let col = 0; col < BOARD_WIDTH; col++) {\r\n      let node = createNode(row, col);\r\n      currRow.push(node);\r\n    }\r\n    board.push(currRow);\r\n  }\r\n  return board;\r\n};\r\n\r\n// Creates a Node object, which combine together to form the board\r\nconst createNode = (row, col) => {\r\n  return {\r\n    row,\r\n    col,\r\n    distance: Infinity,\r\n    isVisited: false,\r\n    parentNode: null,\r\n    isWall: false,\r\n    isSourceNode: row === SOURCE_NODE_ROW && col === SOURCE_NODE_COL,\r\n    isTargetNode: row === TARGET_NODE_ROW && col === TARGET_NODE_COL,\r\n  };\r\n};\r\n","import \"./App.css\";\nimport Navbar from \"./components/Navbar/Navbar\";\nimport Visualizer from \"./components/Visualizer/Visualizer\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Navbar />\n      <Visualizer />\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}