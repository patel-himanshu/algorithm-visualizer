{"version":3,"sources":["components/Legend/Legend.js","logo.png","components/Navbar/Navbar.js","algorithms/Dijkstra.js","components/Node/Node.js","components/Visualizer/Visualizer.js","App.js","reportWebVitals.js","index.js"],"names":["Legend","className","name","nodeClass","map","legendItem","idx","style","cursor","Navbar","src","logo","alt","dijkstra","board","sourceNode","targetNode","result","visitedNodes","pathExists","distance","priorityQueue","allNodes","row","node","push","getAllNodes","length","sort","node1","node2","nearestNeighbourNode","shift","isWallNode","Infinity","isVisited","updateNeighbourNodes","unvisitedNeighbours","neighbours","col","rowLength","colLength","filter","neighbour","getUnvisitedNeighbours","parentNode","Node","props","isSourceNode","isTargetNode","onClick","otherClassName","id","BOARD_WIDTH","Math","floor","window","innerWidth","SOURCE_NODE_ROW","random","SOURCE_NODE_COL","TARGET_NODE_ROW","TARGET_NODE_COL","createNode","Visualizer","useState","setBoard","isVisualizationStarted","setIsVisualizationStarted","pathLength","setPathLength","numNodesVisited","setNumNodesVisited","boardRow","boardCol","useEffect","currRow","getBoardArray","animateShortestPath","shortestPathOrder","document","getElementById","i","setTimeout","visualize","animateDijkstra","unshift","pop","getShortestPath","handleNodeClick","newBoard","rowElem","rowIdx","colElem","colIdx","finalMessage","border","onMouseDown","e","preventDefault","disabled","wallRow","wallCol","console","log","handleRandomWallsCreation","location","reload","boardRowIdx","boardColIdx","textShadow","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.1a0ce0ac.chunk.js","sourcesContent":["import React from \"react\";\r\nimport \"./Legend.css\";\r\n\r\nconst Legend = () => {\r\n\tconst legend = [\r\n\t\t{ name: \"Source Node\", nodeClass: \"node-source\" },\r\n\t\t{ name: \"Target Node\", nodeClass: \"node-target\" },\r\n\t\t{ name: \"Wall Node\", nodeClass: \"node-wall\" },\r\n\t\t{ name: \"Unvisited Node\", nodeClass: \"node\" },\r\n\t\t{ name: \"Visited Node\", nodeClass: \"node-visited\" },\r\n\t\t{\r\n\t\t\tname: \"Shortest Path\",\r\n\t\t\tnodeClass: \"node-shortest-path node-legend-final\",\r\n\t\t},\r\n\t];\r\n\r\n\treturn (\r\n\t\t<div className=\"container legend my-2\">\r\n\t\t\t{legend.map((legendItem, idx) => {\r\n\t\t\t\tconst { name, nodeClass } = legendItem;\r\n\r\n\t\t\t\treturn (\r\n\t\t\t\t\t<button\r\n\t\t\t\t\t\tkey={idx}\r\n\t\t\t\t\t\tclassName=\"mr-2 my-1\"\r\n\t\t\t\t\t\tstyle={{ cursor: \"default\" }}\r\n\t\t\t\t\t>\r\n\t\t\t\t\t\t<div className={`node node-legend ${nodeClass}`}></div>{\" \"}\r\n\t\t\t\t\t\t{name}\r\n\t\t\t\t\t</button>\r\n\t\t\t\t);\r\n\t\t\t})}\r\n\t\t\t<div\r\n\t\t\t\tclassName=\"mt-1 font-weight-bold text-danger\"\r\n\t\t\t\tstyle={{ cursor: \"default\" }}\r\n\t\t\t>\r\n\t\t\t\tNote: View on the maximized window of a computer screen for\r\n\t\t\t\tbetter experience.\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t);\r\n};\r\n\r\nexport default Legend;\r\n","export default __webpack_public_path__ + \"static/media/logo.7d7c4567.png\";","import React from \"react\";\r\nimport logo from \"../../logo.png\";\r\nimport \"bootstrap/dist/css/bootstrap.min.css\";\r\nimport \"./Navbar.css\";\r\n\r\nconst Navbar = () => {\r\n\treturn (\r\n\t\t<div>\r\n\t\t\t<nav className=\"navbar text-light sticky-top\">\r\n\t\t\t\t<div className=\"navbar-brand font-weight-bold\">\r\n\t\t\t\t\t<img src={logo} alt=\"Logo\" className=\"logo mr-3\" />\r\n\t\t\t\t\tAlgorithm Visualizer\r\n\t\t\t\t</div>\r\n\t\t\t</nav>\r\n\t\t</div>\r\n\t);\r\n};\r\n\r\nexport default Navbar;\r\n","export function dijkstra(board, sourceNode, targetNode) {\r\n  const result = { visitedNodes: [], pathExists: false };\r\n  sourceNode.distance = 0;\r\n\r\n  // Creates a 1D array of unvisited nodes, which is sorted\r\n  const priorityQueue = getAllNodes(board);\r\n\r\n  while (priorityQueue.length !== 0) {\r\n    // Sorts the priority queue in ascending order w.r.t. distance\r\n    priorityQueue.sort((node1, node2) => node1.distance - node2.distance);\r\n\r\n    // Selects the unvisited node with least distance as nearest node,\r\n    // sets it as the latest visited node and removes it from the unvisited nodes array\r\n    const nearestNeighbourNode = priorityQueue.shift();\r\n\r\n    if (nearestNeighbourNode.isWallNode) continue;\r\n    if (nearestNeighbourNode.distance === Infinity) {\r\n      result.pathExists = false;\r\n      return result;\r\n    }\r\n\r\n    result.visitedNodes.push(nearestNeighbourNode);\r\n    nearestNeighbourNode.isVisited = true;\r\n\r\n    if (nearestNeighbourNode === targetNode) {\r\n      result.pathExists = true;\r\n      return result;\r\n    }\r\n\r\n    updateNeighbourNodes(board, nearestNeighbourNode);\r\n  }\r\n}\r\n\r\n// Creates a 1D array of all nodes of the board\r\nfunction getAllNodes(board) {\r\n  const allNodes = [];\r\n  for (let row of board) {\r\n    for (let node of row) {\r\n      allNodes.push(node);\r\n    }\r\n  }\r\n  return allNodes;\r\n}\r\n\r\n// Get a 1D array of unvisited neighbour nodes of current node\r\nfunction getUnvisitedNeighbours(board, node) {\r\n  const neighbours = [];\r\n  const { row, col } = node;\r\n  const rowLength = board.length;\r\n  const colLength = board[0].length;\r\n\r\n  if (row > 0) neighbours.push(board[row - 1][col]);\r\n  if (col > 0) neighbours.push(board[row][col - 1]);\r\n  if (row < rowLength - 1) neighbours.push(board[row + 1][col]);\r\n  if (col < colLength - 1) neighbours.push(board[row][col + 1]);\r\n\r\n  return neighbours.filter((neighbour) => !neighbour.isVisited);\r\n}\r\n\r\n// Increments the distance of all unvisited neighbour nodes by 1\r\n// Sets the parent node for all unvisited neighbour nodes\r\nfunction updateNeighbourNodes(board, node) {\r\n  const unvisitedNeighbours = getUnvisitedNeighbours(board, node);\r\n\r\n  for (let neighbour of unvisitedNeighbours) {\r\n    neighbour.distance = node.distance + 1;\r\n    neighbour.parentNode = node;\r\n  }\r\n}\r\n\r\n// Returns the shortest path obtained using Dijkstra'a algorithm\r\n// Excludes the source node and the target node\r\nexport function getShortestPath(targetNode) {\r\n  const shortestPathOrder = [];\r\n  let node = targetNode;\r\n  while (node != null) {\r\n    shortestPathOrder.unshift(node);\r\n    node = node.parentNode;\r\n  }\r\n  shortestPathOrder.shift();\r\n  shortestPathOrder.pop();\r\n  return shortestPathOrder;\r\n}\r\n","import React from \"react\";\r\nimport \"./Node.css\";\r\n\r\nconst Node = (props) => {\r\n  const { row, col, isWallNode, isSourceNode, isTargetNode, onClick } = props;\r\n\r\n  let otherClassName = \"\";\r\n  if (isSourceNode) {\r\n    otherClassName = \"node-source\";\r\n  } else if (isTargetNode) {\r\n    otherClassName = \"node-target\";\r\n  } else if (isWallNode) {\r\n    otherClassName = \"node-wall\";\r\n  }\r\n\r\n  return (\r\n    <div\r\n      id={`node-${row}-${col}`}\r\n      className={`node ${otherClassName}`}\r\n      onClick={() => onClick(row, col)}\r\n    ></div>\r\n  );\r\n};\r\n\r\nexport default Node;\r\n","import { useState, useEffect } from \"react\";\r\nimport { dijkstra, getShortestPath } from \"../../algorithms/Dijkstra\";\r\nimport Node from \"../Node/Node\";\r\nimport \"./Visualizer.css\";\r\n\r\nconst BOARD_HEIGHT = 10;\r\nconst BOARD_WIDTH = Math.floor(window.innerWidth / 40);\r\nconst SOURCE_NODE_ROW = Math.floor(Math.random() * BOARD_HEIGHT);\r\nconst SOURCE_NODE_COL = Math.floor(Math.random() * BOARD_WIDTH);\r\nconst TARGET_NODE_ROW = Math.floor(Math.random() * BOARD_HEIGHT);\r\nconst TARGET_NODE_COL = Math.floor(Math.random() * BOARD_WIDTH);\r\n\r\n// Creates a 2D array of board, of given dimensions\r\n// Each node of the board, has its own set of properties\r\nconst getBoardArray = () => {\r\n  const board = [];\r\n  for (let row = 0; row < BOARD_HEIGHT; row++) {\r\n    let currRow = [];\r\n    for (let col = 0; col < BOARD_WIDTH; col++) {\r\n      let node = createNode(row, col);\r\n      currRow.push(node);\r\n    }\r\n    board.push(currRow);\r\n  }\r\n  return board;\r\n};\r\n\r\n// Creates a Node object, which combine together to form the board\r\nconst createNode = (row, col) => {\r\n  return {\r\n    row,\r\n    col,\r\n    distance: Infinity,\r\n    isVisited: false,\r\n    parentNode: null,\r\n    isWallNode: false,\r\n    isSourceNode: row === SOURCE_NODE_ROW && col === SOURCE_NODE_COL,\r\n    isTargetNode: row === TARGET_NODE_ROW && col === TARGET_NODE_COL,\r\n  };\r\n};\r\n\r\nconst Visualizer = () => {\r\n  const [board, setBoard] = useState([]);\r\n  const [isVisualizationStarted, setIsVisualizationStarted] = useState(false);\r\n  const [pathLength, setPathLength] = useState(null);\r\n  const [numNodesVisited, setNumNodesVisited] = useState(0);\r\n\r\n  const [boardRow, setBoardRow] = useState(BOARD_WIDTH);\r\n  const [boardCol, setBoardCol] = useState(BOARD_HEIGHT);\r\n  const [sourceRow, setSourceRow] = useState(SOURCE_NODE_ROW);\r\n  const [sourceCol, setSourceCol] = useState(SOURCE_NODE_COL);\r\n  const [targetRow, setTargetRow] = useState(TARGET_NODE_ROW);\r\n  const [targetCol, setTargetCol] = useState(TARGET_NODE_COL);\r\n\r\n  // Creates a 2D board array after the mounting phase of the component gets completed\r\n  useEffect(() => {\r\n    const board = getBoardArray();\r\n    setBoard(board);\r\n  }, []);\r\n\r\n  const animateDijkstra = (visitedNodes, pathExists, shortestPathOrder) => {\r\n    for (let i = 0; i <= visitedNodes.length; i++) {\r\n      if (i === visitedNodes.length) {\r\n        setTimeout(() => {\r\n          animateShortestPath(shortestPathOrder, pathExists);\r\n        }, 20 * i);\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodes[i];\r\n        if (\r\n          !(node.row === SOURCE_NODE_ROW && node.col === SOURCE_NODE_COL) &&\r\n          !(node.row === TARGET_NODE_ROW && node.col === TARGET_NODE_COL)\r\n        ) {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-visited\";\r\n        }\r\n      }, 20 * i);\r\n    }\r\n  };\r\n\r\n  const animateShortestPath = (shortestPathOrder, pathExists) => {\r\n    document.getElementById(\r\n      `node-${SOURCE_NODE_ROW}-${SOURCE_NODE_COL}`\r\n    ).className = \"node node-source node-final\";\r\n\r\n    for (let i = 0; i < shortestPathOrder.length; i++) {\r\n      setTimeout(() => {\r\n        const node = shortestPathOrder[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node-shortest-path node-final\";\r\n      }, 100 * i);\r\n    }\r\n\r\n    document.getElementById(\r\n      `node-${TARGET_NODE_ROW}-${TARGET_NODE_COL}`\r\n    ).className = \"node node-target node-final\";\r\n\r\n    if (pathExists) {\r\n      setPathLength(shortestPathOrder.length);\r\n    } else {\r\n      setPathLength(Infinity);\r\n    }\r\n  };\r\n\r\n  const visualize = () => {\r\n    setIsVisualizationStarted(true);\r\n    const sourceNode = board[SOURCE_NODE_ROW][SOURCE_NODE_COL];\r\n    const targetNode = board[TARGET_NODE_ROW][TARGET_NODE_COL];\r\n    const { visitedNodes, pathExists } = dijkstra(\r\n      board,\r\n      sourceNode,\r\n      targetNode\r\n    );\r\n    const shortestPathOrder = getShortestPath(targetNode);\r\n    animateDijkstra(visitedNodes, pathExists, shortestPathOrder);\r\n    setNumNodesVisited(visitedNodes.length);\r\n  };\r\n\r\n  // =========== EVENT HANDLERS ===========\r\n\r\n  const handleRandomWallsCreation = () => {\r\n    const wallsNum = 1;\r\n    // const wallsNum = Math.floor(BOARD_HEIGHT * BOARD_WIDTH * 0.4);\r\n    // console.log(BOARD_HEIGHT * BOARD_WIDTH, wallsNum);\r\n    let i = 0;\r\n    while (i < wallsNum) {\r\n      let wallRow = Math.floor(Math.random() * BOARD_HEIGHT);\r\n      let wallCol = Math.floor(Math.random() * BOARD_WIDTH);\r\n      let node = board[wallRow][wallCol];\r\n\r\n      if (node.isSourceNode || node.isTargetNode) {\r\n        console.log(i, \"pass\");\r\n        continue;\r\n      } else {\r\n        handleNodeClick(wallRow, wallCol);\r\n        i++;\r\n        // console.log(i, wallRow, wallCol);\r\n      }\r\n    }\r\n  };\r\n\r\n  const handleBoardReset = () => {\r\n    window.location.reload(false);\r\n    setIsVisualizationStarted(false);\r\n    // const board = getBoardArray();\r\n    // setBoard(board);\r\n    // setPathLength(0);\r\n  };\r\n\r\n  const handleNodeClick = (row, col) => {\r\n    if (!isVisualizationStarted) {\r\n      let newBoard = board.map((rowElem, rowIdx) => {\r\n        if (rowIdx === row) {\r\n          let newRow = rowElem.map((colElem, colIdx) => {\r\n            if (colIdx === col) {\r\n              return {\r\n                ...colElem,\r\n                isWallNode: !colElem.isWallNode,\r\n              };\r\n            } else {\r\n              return colElem;\r\n            }\r\n          });\r\n          return newRow;\r\n        } else {\r\n          return rowElem;\r\n        }\r\n      });\r\n      setBoard(newBoard);\r\n    }\r\n  };\r\n\r\n  // Determines the final message shown after visualization is completed\r\n  let finalMessage =\r\n    pathLength === Infinity\r\n      ? \"There is no path connecting the source and target node\"\r\n      : pathLength === 0\r\n      ? \"The source and target nodes are adjacent to each other\"\r\n      : `The number of nodes in shortest path between source and target\r\n    node: ${pathLength}`;\r\n\r\n  return (\r\n    <div className=\"visualizer\">\r\n      {/* Action Buttons */}\r\n      <button\r\n        className=\"btn btn-warning mt-4 mr-2\"\r\n        style={{ border: \"2px solid black\" }}\r\n        onClick={() => visualize()}\r\n        onMouseDown={(e) => e.preventDefault()}\r\n        disabled={isVisualizationStarted}\r\n      >\r\n        Visualize Dijkstra's Algorithm\r\n      </button>\r\n      <button\r\n        className=\"btn btn-secondary mt-4\"\r\n        style={{ border: \"2px solid black \" }}\r\n        onClick={() => handleRandomWallsCreation()}\r\n        onMouseDown={(e) => e.preventDefault()}\r\n        disabled={isVisualizationStarted}\r\n      >\r\n        Create Random Wall\r\n        {/* Create Random Walls */}\r\n      </button>\r\n      <button\r\n        className=\"btn btn-danger mt-4 ml-2\"\r\n        style={{ border: \"2px solid black\" }}\r\n        onClick={() => handleBoardReset()}\r\n        onMouseDown={(e) => e.preventDefault()}\r\n      >\r\n        Reset Board\r\n      </button>\r\n\r\n      {/* Board Details */}\r\n      <div className=\"container mt-2\">\r\n        <h4>\r\n          Board has {boardRow} rows and {boardCol} columns\r\n        </h4>\r\n      </div>\r\n\r\n      {/* Board Layout */}\r\n      <div className=\"mb-2\">\r\n        <div className=\"board-layout\">\r\n          {board.map((boardRow, boardRowIdx) => {\r\n            return (\r\n              <div key={boardRowIdx} className=\"board-row\">\r\n                {boardRow.map((boardCol, boardColIdx) => {\r\n                  const { row, col, isWallNode, isSourceNode, isTargetNode } =\r\n                    boardCol;\r\n                  return (\r\n                    <Node\r\n                      key={boardColIdx}\r\n                      row={row}\r\n                      col={col}\r\n                      isWallNode={isWallNode}\r\n                      isSourceNode={isSourceNode}\r\n                      isTargetNode={isTargetNode}\r\n                      onClick={(row, col) => handleNodeClick(row, col)}\r\n                    />\r\n                  );\r\n                })}\r\n              </div>\r\n            );\r\n          })}\r\n        </div>\r\n\r\n        {/* Final message after visualization completion */}\r\n        {pathLength !== null && (\r\n          <div className=\"message\">\r\n            <h4 style={{ textShadow: \"0 0 10px orange\" }}>{finalMessage}</h4>\r\n            <h5>\r\n              The total number of nodes visited (including both nodes):{\" \"}\r\n              {numNodesVisited}\r\n            </h5>\r\n          </div>\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Visualizer;\r\n","import \"./App.css\";\nimport Legend from \"./components/Legend/Legend\";\nimport Navbar from \"./components/Navbar/Navbar\";\nimport Visualizer from \"./components/Visualizer/Visualizer\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Navbar />\n      <Visualizer />\n      <Legend />\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}